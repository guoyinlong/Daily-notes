<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <script>
    /*
    1. 闭包的概念：
    闭包就是能够读取其他函数内部变量的函数.

    例如:
    */
    function f1() {
      var n = 999;

      function f2() {
        alert(n);
      }
      return f2;
    }
    var result = f1();
    result(); // 999
    /*
    其中f2函数就是闭包。
    由于在Javascript语言中， 只有函数内部的子函数才能读取局部变量，
    因此可以把闭包简单理解成 "定义在一个函数内部的函数"。
    所以， 在本质上， 闭包就是将函数内部和函数外部连接起来的一座桥梁。
    2. 闭包的用途：
    闭包可以用在许多地方。 它的最大用处有两个， 一个是前面提到的可以读取函数内部的变量，
    另一个就是让这些变量的值始终保持在内存中。
    怎么来理解这句话呢？ 请看下面的代码。
    */
    function f1() {
      var n = 999;
      nAdd = function () {
        n += 1
      }

      function f2() {
        alert(n);
      }
      return f2;
    }
    var result = f1();
    result(); // 999
    nAdd();
    result(); // 1000
    /*
    在这段代码中， result实际上就是闭包f2函数。 它一共运行了两次， 第一次的值是999，
    第二次的值是1000。 这证明了， 函数f1中的局部变量n一直保存在内存中， 并没有在f1调用后被自动清除。
    为什么会这样呢？ 原因就在于f1是f2的父函数， 而f2被赋给了一个全局变量， 这导致f2始终在内存中，
    而f2的存在依赖于f1， 因此f1也始终在内存中， 不会在调用结束后， 被垃圾回收机制（ garbage collection） 回收。
    这段代码中另一个值得注意的地方， 就是 "nAdd=function(){n+=1}"
    这一行，
    首先在nAdd前面没有使用var关键字， 因此nAdd是一个全局变量， 而不是局部变量。
    其次， nAdd的值是一个匿名函数（ anonymous
    function）， 而这个匿名函数本身也是一个闭包，
    所以nAdd相当于是一个setter， 可以在函数外部对函数内部的局部变量进行操作。

　闭包就是有权访问另一个函数作用域中变量的函数.

　　1.闭包是定义在函数中的函数.
　　2.闭包能访问包含函数的变量.
　　3.即使包含函数执行完了, 被闭包引用的变量也得不到释放.


单词:
index 首页
absolute 绝对定位
relative 相对定位
option 选项栏
number 数字
string 字符串
code 代码
find 查找
write 输入
return 返回






    */
  </script>
</body>

</html>