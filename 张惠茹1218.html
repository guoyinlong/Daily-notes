<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        // 内置对象：String Number Object Array Boolean Regexp function

        //  面向对象
        //  三个基本特征： 封装， 继承， 多态。

        // 1. 对象的创建

        //字面量
        var c1 = {}
            //2.构造函数 系统  实例化对象
        var c2 = new Object()
        c2.name = 'm2';
        c2.age = 20;

        //自己创建构造函数
        function Cat(name) {
            this.name = name
        }
        var c3 = new Car('m3')
            //含有一个constructor属性，指向它们的构造函数。

        //工厂函数
        function cat(name) {
            return {
                name: name
            }
        }
        var c1 = cat('m1')
        console.log(c1);

        //指定原型进行对象的创建

        var o = {
            age: 3
        }
        var x = Object.create(o)
        console.dir(x);

        console.log(o);
        //


        // Prototype验证方法
        //这个方法用来判断， 某个proptotype对象和某个实例之间的关系
        isPrototypeOf()
            // 判断某一个属性到底是本地属性，还是继承自prototype对象的属性
        hasOwnProperty()

        //in运算符可以用来判断， 某个实例是否含有某个属性

        //原始封装方法：浪费内存

        //工厂方法：节省代码量，没有关联性，浪费内存

        //构造函数：减少代码量，节省内存空间，规定了原生的继承原则

        //在函数的调用之前加上new关键字，这个函数的调用结果是一个对象

        //函数调用的几种方式？
        //new  call  bind  apply   h函数的方法

        //new 操作符：创建了一个对象{}，将函数体内的this指向这个新创建出来的对象

        //并且把函数体内的所有代码（属性 与 方法），并且制定这个空对象的原型与原型链这个空对象上面输出这个对象

        //构造函数实例化对象会自动生成一个constructor属性，指向创建他们的构造函数

        //instanceof，验证原型对象与实例对象之间的关系
    </script>

</body>

</html>